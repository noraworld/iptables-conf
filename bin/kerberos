#!/bin/sh
# shellcheck disable=SC2004

# Usage:
#   $PROG_NAME reject /etc/dnsmasq.toggle/youtube.conf
#   $PROG_NAME delete /etc/dnsmasq.toggle/youtube.conf

set -eu


apply() {
  if [ "$DRY_RUN" ]; then
    if [ -f "$2" ]; then
      cat "$2"
    else
      find -L "$2" -not -path '*/\.*' -type f | awk -F / '{ print $NF, $0 }' | sort | sed 's/.* //' | xargs cat
    fi
  else
    if [ -f "$2" ]; then
      # ShellCheck tells a lie
      # shellcheck disable=SC2024
      sudo iptables-restore < "$2"
    else
      find -L "$2" -not -path '*/\.*' -type f | awk -F / '{ print $NF, $0 }' | sort | sed 's/.* //' | xargs cat | sudo iptables-restore
    fi
  fi
}


convert() {
  chain_name_upcase=$(chain_name_upcase "$@")
  block_list=$(block_list "$@")
  white_list=$(white_list "$@")

  if [ "$block_list" != "" ]; then
    echo "-N ${chain_name_upcase}_REJECT"
    echo "-A ${chain_name_upcase}_REJECT -j REJECT"

    echo "$block_list" | while read -r line; do
      if [ "$line" = "#" ]; then
        echo "# WIP: I have no clue how to reject all packets but some other ones."
      else
        echo "$CHAIN" | tr ',' "\n" | xargs -I {} echo "-I {} -p all -m comment --comment \"$line\" -m string --hex-string \"$(hex_string_domain "$line")\" --algo bm -j ${chain_name_upcase}_REJECT"
      fi
    done
  fi

  if [ "$white_list" != "" ]; then
    echo "-N ${chain_name_upcase}_ACCEPT"
    echo "-A ${chain_name_upcase}_ACCEPT -j ACCEPT"

    echo "$white_list" | while read -r line; do
      if [ "$line" = "#" ]; then
        echo "# WIP: I have no clue how to reject all packets but some other ones."
      else
        echo "$CHAIN" | tr ',' "\n" | xargs -I {} echo "-I {} -p all -m comment --comment \"$line\" -m string --hex-string \"$(hex_string_domain "$line")\" --algo bm -j ${chain_name_upcase}_ACCEPT"
      fi
    done
  fi
}


delete() {
  echo "WIP"
  return

  while [ "$(sudo iptables -L OUTPUT | grep -c "^$chain_name_upcase\s")" -ne 0 ]; do
    sudo iptables -D OUTPUT "$(sudo iptables -L OUTPUT --line-numbers | grep -m1 "$chain_name_upcase\s" | awk '{ print $1 }')"
  done

  while [ "$(sudo iptables -L FORWARD | grep -c "^$chain_name_upcase\s")" -ne 0 ]; do
    sudo iptables -D FORWARD "$(sudo iptables -L FORWARD --line-numbers | grep -m1 "$chain_name_upcase\s" | awk '{ print $1 }')"
  done
}


block_list() {
  grep -E "^address=/(.*)/" "$2" | sed -r 's/address=\/(.*)\/.*/\1/' | sed -r 's/\//\n/g'
}


white_list() {
  grep -E "^server=/(.*)/" "$2" | sed -r 's/server=\/(.*)\/.*/\1/' | sed -r 's/\//\n/g'
}


chain_name_upcase() {
  basename "$2" | cut -f 1 -d '.' | tr '[:lower:]' '[:upper:]'
}


list() {
  output_list=$(sudo iptables -L OUTPUT --line-numbers)
  forward_list=$(sudo iptables -L FORWARD --line-numbers)

  if [ "$2" = "all" ]; then
    echo "$output_list"
    echo
    echo "$forward_list"
  else
    if [ "$(echo "$output_list" | grep -c "$chain_name_upcase")" -gt 0 ]; then
      echo "$output_list" | head -2
      echo "$output_list" | grep "$chain_name_upcase"
    fi

    if [ "$(echo "$forward_list" | grep -c "$chain_name_upcase")" -gt 0 ]; then
      # just for format
      if [ "$(echo "$output_list" | grep -c "$chain_name_upcase")" -gt 0 ]; then
        echo
      fi

      echo "$forward_list" | head -2
      echo "$forward_list" | grep "$chain_name_upcase"
    fi
  fi
}


hex_string_domain() {
  domain_fragments=$(echo "$1" | sed -r "s/\./\n/g")
  # https://stackoverflow.com/a/33256019/13999144
  lengths=$(echo "$domain_fragments" | awk '{ print length }' | xargs -I {} printf "|%02d|\n" "{}")

  # https://unix.stackexchange.com/a/639752
zebra=$(paste -d "\n" /dev/fd/3 3<<-EOF /dev/fd/4 4<<-EOF
$lengths
EOF
$domain_fragments
EOF
)

  echo "$zebra" | sed -z 's/\n//g' | sed 's/^.\{4\}//'; echo
}


validate() {
  if [ ! -f "$2" ] && [ "$2" != "all" ]; then
    echo "No such file: $2" >&2
    exit 1
  fi
}


# gengetoptions embed --overwrite $PROG_NAME
# @getoptions
PROG_NAME="kerberos"

parser_definition() {
  setup REST help:usage -- "Usage: $PROG_NAME [options]... [arguments]..." ''
  msg -- 'Options:'
  flag DRY_RUN --dry-run -- "WIP"
  param CHAIN --chain -- "WIP"
  disp :usage -h --help -- "Print help message and exit"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DRY_RUN=''
CHAIN=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--dry-run')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DRY_RUN="$OPTARG"
        ;;
      '--chain')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        CHAIN="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: kerberos [options]... [arguments]...

Options:
      --dry-run               WIP
      --chain CHAIN           WIP
  -h, --help                  Print help message and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main() {
  parse "$@"
  eval "set -- $REST"

  case "$1" in
    "reject")
      reject "$@"
      ;;
    "delete")
      delete "$@"
      ;;
    "list")
      list "$@"
      ;;
    *)
      echo "Invalid command" >&2
      ;;
  esac
}

main "$@"
